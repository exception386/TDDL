<script>
        console.log("SCRIPT START: Top-Down Doom-like game script initiated.");

        // Audio initialization
        async function initializeAudio() {
            try {
                if (Tone.context.state === 'suspended') {
                    await Tone.start();
                    console.log("AudioContext started successfully.");
                }
            } catch (e) {
                console.warn("Warning during initial Tone.start():", e);
            }
        }
        initializeAudio();

        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const healthDisplay = document.getElementById('healthDisplay');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const waveDisplay = document.getElementById('waveDisplay');
        const weaponInventoryIcons = document.getElementById('weaponInventoryIcons');
        const messageOverlay = document.getElementById('messageOverlay');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');
        const redKeyIcon = document.getElementById('redKeyIcon');
        const yellowKeyIcon = document.getElementById('yellowKeyIcon');
        const blueKeyIcon = document.getElementById('blueKeyIcon');
        const difficultySelectionDiv = document.getElementById('difficultySelection');
        const difficultyButtons = document.querySelectorAll('.difficulty-button');
        const playerSpriteImage = document.getElementById('playerSprite');
        const instructionsButton = document.getElementById('instructionsButton');
        const instructionsOverlay = document.getElementById('instructionsOverlay');
        const instructionsTextContent = document.getElementById('instructionsTextContent');
        const closeInstructionsButton = document.getElementById('closeInstructionsButton');

        // Game Constants
        const TILE_SIZE = 40;
        const MAP_COLS = 50;
        const MAP_ROWS = 40;
        const VIEWPORT_WIDTH = 800;
        const VIEWPORT_HEIGHT = 600;
        canvas.width = VIEWPORT_WIDTH;
        canvas.height = VIEWPORT_HEIGHT;

        // Player Sprite Constants
        const PLAYER_SPRITE_FRAME_WIDTH = 26;
        const PLAYER_SPRITE_FRAME_HEIGHT = 36;
        const PLAYER_SPRITE_SCALE = 1.2;
        const playerFrames = {
            down:  { x: 3, y: 0 },
            left:  { x: 3, y: 1 },
            right: { x: 3, y: 2 },
            up:    { x: 3, y: 3 },
        };

        const camera = {
            x: 0, y: 0,
            width: VIEWPORT_WIDTH, height: VIEWPORT_HEIGHT,
            update: function(target) {
                if (!target) { return; }
                let targetX = target.x; let targetY = target.y;
                if (isNaN(targetX) || isNaN(targetY)) {
                    console.warn(`Camera target position is NaN (x: ${targetX}, y: ${targetY}). Defaulting target to center.`);
                    targetX = (MAP_COLS * TILE_SIZE) / 2; targetY = (MAP_ROWS * TILE_SIZE) / 2;
                }
                this.x = Math.max(0, Math.min(targetX - this.width / 2, (MAP_COLS * TILE_SIZE) - this.width));
                this.y = Math.max(0, Math.min(targetY - this.height / 2, (MAP_ROWS * TILE_SIZE) - this.height));
                if (isNaN(this.x) || isNaN(this.y)) {
                    console.error(`Camera position became NaN. Resetting to 0,0.`); this.x = 0; this.y = 0;
                }
            }
        };

        // Tile Types
        const TILE_EMPTY = 0, TILE_WALL = 1, TILE_DOOR_RED = 2, TILE_DOOR_YELLOW = 3, TILE_DOOR_BLUE = 4;
        const TILE_KEY_RED = 5, TILE_KEY_YELLOW = 6, TILE_KEY_BLUE = 7, TILE_EXIT = 8;
        const TILE_WEAPON_SHOTGUN = 9, TILE_WEAPON_MACHINEGUN = 10, TILE_WEAPON_ROCKETLAUNCHER = 11, TILE_WEAPON_BFG = 12;
        const TILE_HEALTH_PACK = 13, TILE_SECRET_DOOR = 14;

        const wallStyles = [ /* ... existing wallStyles ... */ ];
        let currentWallStyle = wallStyles[0];

        // Game State Variables
        let player;
        let bullets, enemies, gameMap, healthPacks, ammoPacks, visibilityMap, explosions, temporaryVisualEffects;
        let currentBoss = null;
        let isBossLevel = false;
        let isCurrentLevelMiniBoss = false;
        let nextMiniBossSpawnLevel = 0;
        const MINI_BOSS_SPAWN_INTERVAL_MIN = 2;
        const MINI_BOSS_SPAWN_INTERVAL_MAX = 3;
        let score = 0, currentLevel = 1, gameOver = false, gameRunning = false;
        let enemiesToSpawnPerLevel = 10, enemiesSpawnedThisLevel = 0, enemiesRemaining = 0;
        let gameLoopId, selectedDifficulty = 'medium', isLevelCompleting = false;
        let mainBossJustDefeated = false; // ADDED: Flag for main boss defeat message flow

        const WEAPON_STATS = { /* ... existing WEAPON_STATS ... */ };
        const keys = { /* ... existing keys ... */ };
        const mouse = { x: VIEWPORT_WIDTH / 2, y: VIEWPORT_HEIGHT / 2, down: false };

        let synth, metalSynth, hitSynth, explosionSynth, rocketFireSynth, bfgFireSynth, bossHitSynth, bossDeathSynth;
        let bossRegularShootSynth, bossSeekingShootSynth, ammoPickupSynth, secretDoorOpenSynth;
        let lastHitSoundTime = 0, HIT_SOUND_COOLDOWN = 50;
        let lastEnemyDestroySoundTime = 0, ENEMY_DESTROY_SOUND_COOLDOWN = 100;

        function setupSynths() { /* ... existing setupSynths ... */ }
        async function ensureAudioAndSynths() { /* ... existing ensureAudioAndSynths ... */ }
        function playShootSound(weaponName) { /* ... existing playShootSound ... */ }
        function playHitSound() { /* ... existing playHitSound ... */ }
        function playPlayerHitSound() { /* ... existing playPlayerHitSound ... */ }
        function playEnemyDestroySound() { /* ... existing playEnemyDestroySound ... */ }
        function playRocketExplosionSound() { /* ... existing playRocketExplosionSound ... */ }
        function playBFGImpactSound() { /* ... existing playBFGImpactSound ... */ }
        function playEnemyShootSound() { /* ... existing playEnemyShootSound ... */ }
        function playHealthPickupSound() { /* ... existing playHealthPickupSound ... */ }
        function playKeyPickupSound() { /* ... existing playKeyPickupSound ... */ }
        function playDoorOpenSound() { /* ... existing playDoorOpenSound ... */ }
        function playWeaponPickupSound() { /* ... existing playWeaponPickupSound ... */ }
        function playTeleportSound() { /* ... existing playTeleportSound ... */ }
        function playSplitSound() { /* ... existing playSplitSound ... */ }
        function playEmptyGunSound() { /* ... existing playEmptyGunSound ... */ }
        function playBossHitSound() { /* ... existing playBossHitSound ... */ }
        function playBossDeathSound() { /* ... existing playBossDeathSound ... */ }
        function playBossRegularShootSound() { /* ... existing playBossRegularShootSound ... */ }
        function playBossSeekingShootSound() { /* ... existing playBossSeekingShootSound ... */ }
        function playSecretDoorOpenSound() { /* ... existing playSecretDoorOpenSound ... */ }
        function playAmmoPickupSound() { /* ... existing playAmmoPickupSound ... */ }
        function findPath(startX, startY, endX, endY, currentMap, keysAvailable) { /* ... existing findPath ... */ }
        function findPathForVisibility(startX, startY, endX, endY, currentMap) { /* ... existing findPathForVisibility ... */ }
        function updateVisibility(playerTileX, playerTileY, currentMap) { /* ... existing updateVisibility ... */ }
        function isPathClear(x1, y1, x2, y2, currentMap, step = TILE_SIZE / 4) { /* ... existing isPathClear ... */ }
        function generateMaze(cols, rows, isMainBossLevelLayout) { /* ... existing generateMaze ... */ }
        class HealthPack { /* ... existing HealthPack class ... */ }
        class AmmoPack { /* ... existing AmmoPack class ... */ }

        class Player {
            constructor(x, y) {
                this.x = x; this.y = y; this.radius = TILE_SIZE / 3; this.speed = 3.5;
                this.health = 100; this.maxHealth = 100; this.angle = Math.PI / 2;
                this.keysCollected = { red: false, yellow: false, blue: false };
                this.canPhase = false;
                this.weapons = [];
                for (const weaponKey in WEAPON_STATS) {
                    const stats = WEAPON_STATS[weaponKey];
                    this.weapons.push({ ...stats, damage: stats.damage(), ammo: (stats.name === "Pistol" ? Infinity : 0), owned: (stats.name === "Pistol") });
                }
                this.currentWeaponIndex = this.weapons.findIndex(w => w.name === "Pistol");
                this.shootCooldown = 0; this.justFiredPistolOnThisClick = false;
                this.currentAnimFrame = 0; this.animTimer = 0; this.animSpeed = 8; this.isMoving = false;
            }
            getCurrentWeapon() { return this.weapons[this.currentWeaponIndex]; }
            addWeapon(weaponDataFromTile) { /* ... existing addWeapon ... */ }
            addAmmo(weaponName, amount) { /* ... existing addAmmo ... */ }
            switchWeapon(index) { /* ... existing switchWeapon ... */ }
            draw() { /* ... existing draw ... */ }
            update() { /* ... existing update ... */ }
            checkTileInteraction(tileX, tileY) {
                if (this.canPhase) return false;
                if (tileX < 0 || tileX >= MAP_COLS || tileY < 0 || tileY >= MAP_ROWS) return true;
                const tileType = gameMap[tileY][tileX];
                switch (tileType) {
                    case TILE_WALL: return true;
                    case TILE_DOOR_RED: if (this.keysCollected.red) { gameMap[tileY][tileX] = TILE_EMPTY; playDoorOpenSound(); updateKeyUI(); updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap); return false; } return true;
                    case TILE_DOOR_YELLOW: if (this.keysCollected.yellow) { gameMap[tileY][tileX] = TILE_EMPTY; playDoorOpenSound(); updateKeyUI(); updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap); return false; } return true;
                    case TILE_DOOR_BLUE: if (this.keysCollected.blue) { gameMap[tileY][tileX] = TILE_EMPTY; playDoorOpenSound(); updateKeyUI(); updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap); return false; } return true;
                    case TILE_KEY_RED: this.keysCollected.red = true; gameMap[tileY][tileX] = TILE_EMPTY; playKeyPickupSound(); updateKeyUI(); score += 50; scoreDisplay.textContent = score; return false;
                    case TILE_KEY_YELLOW: this.keysCollected.yellow = true; gameMap[tileY][tileX] = TILE_EMPTY; playKeyPickupSound(); updateKeyUI(); score += 50; scoreDisplay.textContent = score; return false;
                    case TILE_KEY_BLUE: this.keysCollected.blue = true; gameMap[tileY][tileX] = TILE_EMPTY; playKeyPickupSound(); updateKeyUI(); score += 50; scoreDisplay.textContent = score; return false;
                    case TILE_EXIT:
                        if (isCurrentLevelMiniBoss && currentBoss && currentBoss.health > 0) {
                             console.log("Mini-boss alive, cannot exit."); return true;
                        }
                        if (isBossLevel && (currentBoss && currentBoss.health > 0)) { // Check main boss specifically
                            console.log("Main boss is still alive. Exit is locked."); return true;
                        }
                        levelComplete(true); // True completion event
                        return false;
                    case TILE_WEAPON_SHOTGUN: this.addWeapon(WEAPON_STATS["Shotgun"]); gameMap[tileY][tileX] = TILE_EMPTY; return false;
                    case TILE_WEAPON_MACHINEGUN: this.addWeapon(WEAPON_STATS["Machine Gun"]); gameMap[tileY][tileX] = TILE_EMPTY; return false;
                    case TILE_WEAPON_ROCKETLAUNCHER: this.addWeapon(WEAPON_STATS["Rocket Launcher"]); gameMap[tileY][tileX] = TILE_EMPTY; return false;
                    case TILE_WEAPON_BFG: this.addWeapon(WEAPON_STATS["BFG"]); gameMap[tileY][tileX] = TILE_EMPTY; return false;
                    case TILE_HEALTH_PACK: if (player) player.gainHealth(25); gameMap[tileY][tileX] = TILE_EMPTY; return false;
                    case TILE_SECRET_DOOR: gameMap[tileY][tileX] = TILE_EMPTY; playSecretDoorOpenSound(); updateVisibility(Math.floor(this.x / TILE_SIZE), Math.floor(this.y / TILE_SIZE), gameMap); score += 25; scoreDisplay.textContent = score; return false;
                    case TILE_EMPTY: default: return false;
                }
            }
            shoot() { /* ... existing shoot ... */ }
            takeDamage(amount) { if (this.canPhase) return; this.health -= amount; playPlayerHitSound(); if (this.health < 0) this.health = 0; healthDisplay.textContent = Math.round(this.health); }
            gainHealth(amount) { this.health += amount; if (this.health > this.maxHealth) this.health = this.maxHealth; healthDisplay.textContent = Math.round(this.health); playHealthPickupSound(); }
            collectAllKeys() { /* ... existing collectAllKeys ... */ }
            collectAllGuns() { /* ... existing collectAllGuns ... */ }
        }

        class Bullet { /* ... existing Bullet class ... */ }
        function fireBFGTracers(playerOrigin, allTargets, directHitEnemy, tracerDamageValue) { /* ... existing fireBFGTracers ... */ }
        class Explosion { /* ... existing Explosion class ... */ }
        class Enemy { /* ... existing Enemy class ... */ }
        class MiniBoss extends Enemy { /* ... existing MiniBoss class ... */ }
        class Boss extends Enemy { /* ... existing Boss class ... */ } // Note: Boss should extend Enemy or have similar base
        function spawnMiniSplitters(x,y) { /* ... existing spawnMiniSplitters ... */ }

        function startGame() {
            score = 0; currentLevel = 1; gameOver = false; mainBossJustDefeated = false; isLevelCompleting = false;
            nextMiniBossSpawnLevel = 0;
            player = new Player((MAP_COLS * TILE_SIZE) / 2, (MAP_ROWS * TILE_SIZE) / 2);
            if (isNaN(player.x) || isNaN(player.y)) { player.x = VIEWPORT_WIDTH / 2; player.y = VIEWPORT_HEIGHT / 2;}
            initLevel();
        }

        function initLevel() {
            isLevelCompleting = false; // Reset for the new level
            // mainBossJustDefeated should be reset by button clicks or startGame
            gameRunning = true; currentBoss = null;
            isBossLevel = (currentLevel % 5 === 0);
            isCurrentLevelMiniBoss = false;
            if (!isBossLevel) { /* ... mini-boss spawn chance logic ... */ }

            const mapData = generateMaze(MAP_COLS, MAP_ROWS, isBossLevel); gameMap = mapData.gameMap;
            if (player) {
                player.x = mapData.playerStart.c * TILE_SIZE + TILE_SIZE/2;
                player.y = mapData.playerStart.r * TILE_SIZE + TILE_SIZE/2;
                if (!isBossLevel) player.keysCollected = { red: false, yellow: false, blue: false };
            } else { showStartScreen(); return; }

            updateKeyUI(); updateWeaponUI();
            if (player && gameMap && gameMap.length > 0) updateVisibility(Math.floor(player.x / TILE_SIZE), Math.floor(player.y / TILE_SIZE), gameMap);

            bullets = []; enemies = []; healthPacks = []; ammoPacks = []; explosions = []; temporaryVisualEffects = [];
            if(player) camera.update(player);
            scoreDisplay.textContent = score;
            if(player) healthDisplay.textContent = Math.round(player.health); // Initial health display with rounding
            waveDisplay.textContent = currentLevel;
            resetLevelParameters();
            if (isBossLevel) { /* ... spawn main boss ... */ }
            else { /* ... spawn regular/mini-boss enemies ... */ }

            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            messageOverlay.style.display = 'none';
            difficultySelectionDiv.style.display = 'flex';
            if (ctx) draw();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function findRoomsInMap(currentMap) { /* ... existing findRoomsInMap ... */ }
        function resetLevelParameters() { /* ... existing resetLevelParameters ... */ }
        function spawnInitialEnemies() { /* ... existing spawnInitialEnemies ... */ }
        function spawnEnemy(validSpawnLocations) { /* ... existing spawnEnemy ... */ }

        function levelComplete(isTrueCompletionEvent = true) {
            if (mainBossJustDefeated && !isTrueCompletionEvent) {
                gameRunning = false;
                if(gameLoopId) cancelAnimationFrame(gameLoopId);
                messageTitle.textContent = "BOSS DEFEATED!";
                messageText.innerHTML = `The way is clear! Proceed to the exit. <br>Score: ${score}`;
                restartButton.textContent = "Proceed to Exit";
                difficultySelectionDiv.style.display = 'none';
                instructionsButton.style.display = 'none';
                messageOverlay.style.display = 'flex';
            } else if (isTrueCompletionEvent) {
                if (isLevelCompleting && restartButton.textContent === "Next Level") return; // Prevent re-trigger if already on "Next Level" screen
                isLevelCompleting = true;
                gameRunning = false;
                if(gameLoopId) cancelAnimationFrame(gameLoopId);

                let titleText = "Level Cleared!";
                if (isBossLevel) titleText = "BOSS DEFEATED!"; // Generic for main boss, specific message handled above
                else if (isCurrentLevelMiniBoss && (!currentBoss || currentBoss.health <=0) ) titleText = "MINI-BOSS DEFEATED!";

                messageTitle.textContent = titleText;
                messageText.innerHTML = `Level ${currentLevel} complete! Score: ${score} <br> Click 'Next Level' to continue.`;
                restartButton.textContent = "Next Level";
                difficultySelectionDiv.style.display = 'none';
                instructionsButton.style.display = 'none';
                messageOverlay.style.display = 'flex';
            }
        }

        let frameCount = 0;
        function gameLoop(){ /* ... existing gameLoop ... */ }

        function update(){
            try {
                if(!player) { /* ... */ return; }
                player.update(); camera.update(player);
                /* ... visibility, bullets, explosions, items ... */

                if (currentBoss) {
                    currentBoss.update();
                    if (currentBoss.health <= 0) {
                        if (!isLevelCompleting && !mainBossJustDefeated) {
                            if (isBossLevel) {
                                mainBossJustDefeated = true;
                                levelComplete(false); // Show "Proceed to Exit"
                            } else if (isCurrentLevelMiniBoss) {
                                console.log("Mini-boss defeated. Player must reach exit.");
                                // currentBoss will be set to null below, allowing exit.
                            }
                        }
                        if (!mainBossJustDefeated) { // Clear if not a main boss waiting for exit
                            currentBoss = null;
                        }
                    } else { /* ... boss bullet collision ... */ }
                }
                /* ... regular enemy update and collision ... */
                /* ... REMOVED the old levelComplete call based on enemy count ... */
            } catch (e) { /* ... error handling ... */ }
        }

        function draw(){ /* ... existing draw ... */ }
        function drawMetalPattern(x,y,s,c) { /* ... */ }
        function drawStonePattern(x,y,s,c) { /* ... */ }
        function updateKeyUI() { /* ... */ }
        function updateWeaponUI() { /* ... */ }

        function showGameOverScreen() {
            gameOver = true; gameRunning = false; mainBossJustDefeated = false; isLevelCompleting = false;
            messageTitle.textContent = "Game Over!";
            messageText.textContent = `You survived ${currentLevel} levels. Final Score: ${score}`;
            restartButton.textContent = "Restart Game";
            difficultySelectionDiv.style.display = 'flex';
            instructionsButton.style.display = 'block';
            messageOverlay.style.display = 'flex';
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
        }

        function showStartScreen() {
            gameOver = false; mainBossJustDefeated = false; isLevelCompleting = false;
            gameRunning = false;
            messageTitle.textContent = "Top-Down Doom-Like Game";
            messageText.innerHTML = "";
            restartButton.textContent = "Start Game";
            difficultySelectionDiv.style.display = 'flex';
            instructionsButton.style.display = 'block';
            messageOverlay.style.display = 'flex';
        }
        function showInstructions() { /* ... */ }
        function hideInstructions() { /* ... */ }

        difficultyButtons.forEach(button => { /* ... */ });
        window.addEventListener('keydown', (e) => { /* ... existing keydown, ensuring 'L' cheat calls levelComplete(true) ... */
            if (keyName === 'l' && !keys.l_cheat_processed) { keys.l_cheat_processed = true; levelComplete(true); }
        });
        window.addEventListener('keyup', (e) => { /* ... */ });
        canvas.addEventListener('mousemove', (e)=>{ /* ... */ });
        canvas.addEventListener('mousedown', (e)=>{ /* ... */ });
        canvas.addEventListener('mouseup', (e)=>{ /* ... */ });
        canvas.addEventListener('contextmenu', (e)=>e.preventDefault());

        restartButton.addEventListener('click', async () => {
            ensureAudioAndSynths();
            const buttonText = restartButton.textContent.trim();

            if (buttonText === "Proceed to Exit") {
                messageOverlay.style.display = 'none';
                // mainBossJustDefeated is kept true until true level completion or game restart.
                isLevelCompleting = false; // Not in the message display phase anymore
                gameRunning = true;
                if(player) camera.update(player);
                if(!gameOver && gameLoopId === null) { // Resume loop if it was stopped
                    gameLoopId = requestAnimationFrame(gameLoop);
                } else if (!gameOver) {
                     // If loop is already running (e.g. from a quick click), do nothing extra.
                }
                return;
            }

            // For all other actions, reset these flags
            mainBossJustDefeated = false;
            isLevelCompleting = false;
            messageOverlay.style.display = 'none'; // Hide overlay for other actions too

            if (buttonText === "Start Game") {
                startGame();
            } else if (gameOver || buttonText === "Restart Game") {
                startGame();
            } else if (buttonText === "Next Level") {
                currentLevel++;
                initLevel();
            } else {
                console.error("DEBUG: Button text NOT RECOGNIZED:", `"${buttonText}"`);
            }
        });

        instructionsButton.addEventListener('click', showInstructions);
        closeInstructionsButton.addEventListener('click', hideInstructions);
        playerSpriteImage.onload = () => { showStartScreen(); };
        playerSpriteImage.onerror = () => { showStartScreen(); }
        if (playerSpriteImage.complete && playerSpriteImage.naturalHeight !== 0) { showStartScreen(); }
        else if (playerSpriteImage.complete && playerSpriteImage.naturalHeight === 0) { showStartScreen(); }

        console.log("SCRIPT END: Event listeners attached, game ready for user interaction.");
    </script>
</body>
</html>
